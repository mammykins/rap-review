---
title: "Condition handling and defensive programming"
author: "Matthew Gregory"
date: "6 June 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Reviewing the `eesectors` package revealed that we were not fully familiar with the `tryCatch` function and why it is useful when writing functions for your package.  

Accordingly we now work through [Hadley Wockham's chapter](http://adv-r.had.co.nz/Exceptions-Debugging.html#condition-handling) that covers this stuff.

### Quoting Hadley

Not all problems are unexpected. When writing a function, you can often anticipate potential problems (like a non-existent file or the wrong type of input). Communicating these problems to the user is the job of conditions: errors, warnings, and messages.

* Fatal errors are raised by stop() and force all execution to terminate. Errors are used when there is no way for a function to continue.

* Warnings are generated by warning() and are used to display potential problems, such as when some elements of a vectorised input are invalid, like log(-1:2).

* Messages are generated by message() and are used to give informative output in a way that can easily be suppressed by the user (?suppressMessages()). I often use messages to let the user know what value the function has chosen for an important missing argument.

### Why can't I just use `print()`?

Printed output is not a condition, so you can’t use any of the useful condition handling tools you’ll learn about below.

### Condition Handlers

Condition handling tools, like `withCallingHandlers()`, `tryCatch()`, and `try()` allow you to take specific actions when a condition occurs.

### Fail fast

The basic principle of defensive programming is to “fail fast”, to raise an error as soon as something goes wrong. In R, this takes three particular forms: checking that inputs are correct, avoiding non-standard evaluation, and avoiding functions that can return different types of output.

```{r}
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) "a" + d
f(10)

traceback()
```

### tryCatch

```{r}
show_condition <- function(code) {
  tryCatch(code,
    error = function(c) "error",
    warning = function(c) "warning",
    message = function(c) "message"
  )
}
show_condition(stop("Figure 3.1 is broken"))
show_condition(warning("x has some missing values"))

```
Thus we could use this to do what was done in `eesectors` package to catch conditions and then spit out informative text.  

```{r}
library(eesectors)
body(figure3.1)
```

Thus we take the framework provided and adapt it to our cause:

```{r}
i_want_to_catch <- function(x, y) {
    out <- tryCatch(expr = {
        
        z <- x + y
        return(z)
    }, warning = function() {
        w <- warnings()
        warning("Warning produced running figure3.1():", w)
    }, error = function(e) {
        stop("Error produced running figure3.1():", e)
    }, finally = {
    })
}
```

Let's try to make it error and warning to see what happens:

```{r}
i_want_to_catch(5, 5)
i_want_to_catch(5, "5")


```

### Fail fast

In R, the “fail fast” principle is implemented in three ways:

Be strict about what you accept. For example, if your function is not vectorised in its inputs, but uses functions that are, make sure to check that the inputs are scalars. You can use `stopifnot()`, the `assertthat` package, or simple if statements and `stop()`.

Avoid functions that use non-standard evaluation, like subset, transform, and with. These functions save time when used interactively, but because they make assumptions to reduce typing, when they fail, they often fail with uninformative error messages. You can learn more about non-standard evaluation in non-standard evaluation. 

It's important to use the standard evaluation verbs versions of `dplyr` functions.

Avoid functions that return different types of output depending on their input.

## Take away

We have a foundation for condition handling and some principles for defensive programming.
